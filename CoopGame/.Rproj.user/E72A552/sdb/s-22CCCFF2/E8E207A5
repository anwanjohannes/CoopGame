{
    "collab_server" : "",
    "contents" : "#' @name coreVertices\n#' @title coreVertices\n#' @description Calculates the core for given game vector A.\n#' @aliases coreVertices\n#' @import rcdd\n#' @importFrom grDevices chull\n#' @export coreVertices\n#' @template author/FM\n#' @template cites/AUMANN_1961\n#' @templateVar AUMANN_1961_P pp. 539--552\n#' @template cites/PELEG_ET_SUDHOELTER_2007\n#' @templateVar PELEG_ET_SUDHOELTER_2007_P p. 27\n#' @template cites/MASCHLER_ET_SOLAN_ET_ZAMIR_2013\n#' @templateVar MASCHLER_ET_SOLAN_ET_ZAMIR_2013_P p. 686 ff.\n#' @template cites/OSBORNE_ET_RUBINSTEIN_1994\n#' @templateVar OSBORNE_ET_RUBINSTEIN_1994_P p. 257 ff.\n#' @inheritParams CoopGameBaseParams\n#' @return rows of the matrix are the vertices of the core\n#' @examples\n#' library(CoopGame)\n#' #In the following case the core consists of a single point\n#' A1 = c(0,1,2,3,4,5,6)\n#' coreVertices(A1)\n#' #     [,1] [,2] [,3]\n#' #[1,]    1    2    3\n#' \n#' #Users may also want to try the following game vectors:\n#' #A2 = c(0,0,0,60,80,100,135)\n#' #A3 = c(5,2,4,7,15,15,15,15,15,15,20,20,20,20,35)\n#' #A4 = c(0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,15,15,15,15,15,15,15,15,15,15,30,30,30,30,30,60)\ncoreVertices<-function(A){\n  wv=CoreConcept(A)\n  payoffSpace=calculateSetSolution(wv)\n  return(payoffSpace@VRepMatrix)\n}\n\n\nlogicCoreVertices <- function(A){ \n  numberOfPlayers = getNumberOfPlayers(A)\n  retVal=NULL\n    if(isEssentialGame(A) == TRUE){\n      vectorA1 = c()\n      \n      #Calculate the matrixA1 for the function makeH\n      vectorRechnung = c(rep(0,(numberOfPlayers - 1)),c(1))\n      vectorA1 = c(1, rep(0,(numberOfPlayers - 1)))\n      b = TRUE\n\n      \n      #Build the matrices and vectors for the function makeH\n      # matrixA1b = -t(matrix(vectorA1,numberOfPlayers,(length(A) - 1)))\n      matrixA1 = -createBitMatrix(n=numberOfPlayers)[-length(A),-(numberOfPlayers+1)]#-t(matrix(vectorA1,numberOfPlayers,(length(A) - 1)))\n      matrixA2 = -matrix(rep(1,numberOfPlayers),1,numberOfPlayers)\n      vectorB1 = -A[1:(length(A)-1)]\n      vectorB2 = -A[length(A)]\n      \n      # Utilize the R-Package rcdd\n      hRepresentation = makeH(matrixA1,vectorB1,matrixA2,vectorB2)\n      vRepresentation = scdd(hRepresentation)\n      if (nrow(vRepresentation$output) >= 2)\n      {\n        vRepresentation = redundant(vRepresentation$output, representation = \"V\")\n      }\n      \n      #Transform the V-Representation into a matrix\n      VectorCounter = length(vRepresentation[[1]]) / (numberOfPlayers + 2)\n      OutcomeVector = vRepresentation[[1]][(VectorCounter * 2 + 1):(length(vRepresentation[[1]]))]\n      ResultMatrix = matrix(OutcomeVector, VectorCounter, numberOfPlayers)   \n      \n      if(numberOfPlayers == 3)\n      {\n      sequencevector = grDevices::chull(ResultMatrix)\n      OutcomeMatrix = ResultMatrix[sequencevector,,drop = FALSE]\n      }\n      else\n      {\n        OutcomeMatrix = ResultMatrix\n      }\n      \n      retVal=OutcomeMatrix\n    }\n    else\n    {\n      print(\"The imputation set is empty\")\n      retVal=matrix(ncol = numberOfPlayers,nrow = 0)\n    }\n    return(retVal)\n}\n\n#' @title CoreConcept - Virtual class for point valued solution concepts\n#' @noRd\n#' @include SetSolutionConcept.R\n#' #@exportClass CoreConcept\n\nsetClass(\n  \"CoreConcept\",\n  contains = \"SetSolutionConcept\"\n)\n\n#' @title Constructor for CoreConcept\n#' @noRd\n#' @description Constructor for CoreConcept\n#' @template author/JA\n#' @name CoreConcept\n#' @include PayoffSpace.R\n#' #@export\nCoreConcept<-function(A){\n  retCoreConcept=methods::new(\"CoreConcept\",A)\n  return(retCoreConcept)\n}\n\n#' @rdname getSetSolutionVertices-methods\n#' @aliases getSetSolutionVertices,CoreConcept-method\nsetMethod(\n  \"getSetSolutionVertices\",\n  signature=\"CoreConcept\",\n  definition=function(.Object){\n    A<-.Object@A\n    VRep=(logicCoreVertices(A))\n    return(VRep)\n  }\n)\n\n#' @name belongsToCore\n#' @title belongsToCore for a TU Game with n players\n#' @description Checks if a given point is in the core\n#' @export belongsToCore\n#' @template author/FM\n#' @template param/A\n#' @template param/x\n#' @return \\code{TRUE} for a point belonging to the core and \\code{FALSE} otherwise\n#' @examples\n#' library(CoopGame)\n#' A = c(0,1,2,3,4,5,6)\n#' belongsToCore(c(1,2,3),A)\n#' #[1] TRUE\n\nbelongsToCore<-function(x,A){\n  cv=coreVertices(A) \n  ps=PayoffSpace(VRepMatrix=cv)\n  return(isElementOfPayoffSpace(ps,x=x))\n}\n\n\n#' @name drawCore\n#' @title drawCore for n players\n#' @description drawCore draws the core set for 3 or 4 players.\n#' @aliases drawCore\n#' @export drawCore\n#' @template author/JA\n#' @template cites/AUMANN_1961\n#' @templateVar AUMANN_1961_P pp. 539--552\n#' @template cites/PELEG_ET_SUDHOELTER_2007\n#' @templateVar PELEG_ET_SUDHOELTER_2007_P p. 27\n#' @template cites/MASCHLER_ET_SOLAN_ET_ZAMIR_2013\n#' @templateVar MASCHLER_ET_SOLAN_ET_ZAMIR_2013_P p. 686 ff.\n#' @template cites/OSBORNE_ET_RUBINSTEIN_1994\n#' @templateVar OSBORNE_ET_RUBINSTEIN_1994_P p. 257 ff.\n#' @inheritParams CoopGameBaseParams\n#' @inheritParams visualize\n#' @return draw core for given game vector with 3 or 4 players\n#' @examples\n#' library(CoopGame)\n#' A <- c(0,0,0,3,3,3,6)\n#' drawCore(A)\n#' \ndrawCore<-function(A,holdOn=FALSE, colour = \"red\" , label=FALSE, name = \"Core\"){\n  A=GameVector(A)\n  co=coreVertices(A);\n  visualize(A, pointsToDraw=co, holdOn=holdOn, colour = colour , label=label, name = name)\n}",
    "created" : 1534322183245.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3472883873",
    "id" : "E8E207A5",
    "lastKnownWriteTime" : 1537215659,
    "last_content_update" : 1537215659,
    "path" : "C:/Users/Johannes/Dropbox/UNIVERSITAET/Master_Inf/MASTER_ARBEIT/SVN_REPO/CoopGame/R/CoreConcept.R",
    "project_path" : "R/CoreConcept.R",
    "properties" : {
    },
    "relative_order" : 76,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}