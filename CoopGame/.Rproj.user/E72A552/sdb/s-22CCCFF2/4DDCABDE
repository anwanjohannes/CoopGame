{
    "collab_server" : "",
    "contents" : "#' @name banzhafValue\n#' @title banzhafValue\n#' @description banzhafValue computes the Banzhaf Value for a specified TU game\n#'              The Banzhaf value itself is an alternative to the Shapley value. \\cr\n#'              Conceptually, the Banzhaf value is very similar to the Shapley value. \n#'              Its main difference from the Shapley value is that the Banzhaf Value is coalition\n#'              based rather than permutation based. Hence the factors by which we multiply the marginal contributions. \\cr\n#'              Shapley factor: \\eqn{((k-1)!*(n-k))}\\cr\n#'              Banzhaf factor: \\eqn{(1/(2^(n-1))} \\cr\n#'              Note that in general the Banzhaf vector is not efficient!\n#'\n#' @aliases banzhafValue\n#' @export banzhafValue\n#' @template author/JA\n#' @template author/JS\n#' @template cites/PETERS_2015\n#' @templateVar PETERS_2015_P pp. 367\n#' @template cites/CHAKRAVARTY_ET_AL_2015\n#' @templateVar CHAKRAVARTY_ET_AL_2015_P p. 118 f.\n#' @inheritParams CoopGameBaseParams \n#' @template param/test\n#' @return The return value is a vector which contains the Banzhaf value for each player.\n#' @examples\n#' A=c(0,0,0,2,2,3,5)\n#' banzhafValue(A)\n#' #[1] 1.5 2.0 2.0\n#' \nbanzhafValue<-function(A){\n  bv=BanzhafConcept(A)\n  n = getNumberOfPlayers(A)\n  banzhafFactor=1/(2^(n-1))\n  return(calculatePowerIndex(bv)*banzhafFactor)\n}\n\n#' @name rawBanzhafValue\n#' @title rawBanzhafValue\n#' @description raw Banzhaf Value, i.e. the Banzhaf Value without the scaling factor \\eqn{(1/(2^(n-1))} \n#' @aliases rawBanzhaValue\n#' @export rawBanzhafValue\n#' @template author/JS\n#' @template cites/PETERS_2015\n#' @templateVar PETERS_2015_P p. 367 ff.\n#' @template cites/CHAKRAVARTY_ET_AL_2015\n#' @templateVar CHAKRAVARTY_ET_AL_2015_P p. 118 f.\n#' @inheritParams CoopGameBaseParams\n#' @return The return value is a vector which contains the raw Banzhaf value for each player.\n#' @examples \n#' A<- c(0,0,0,2,2,3,5)\n#' rawBanzhafValue(A)\n#' #[1] 6 8 8\n#' \nrawBanzhafValue<-function(A){\n  bi=BanzhafConcept(A)\n  n = getNumberOfPlayers(A)\n  return(calculatePowerIndex(bi))\n}\n\n#' @name rawBanzhafIndex\n#' @title rawBanzhafIndex\n#' @description Raw Banzhaf Index for a specified simple game \n#' @aliases rawBanzhafIndex\n#' @export rawBanzhafIndex\n#' @template author/JA\n#' @template author/JS\n#' @template cites/PETERS_2015\n#' @templateVar PETERS_2015_P p. 367 ff.\n#' @template cites/CHAKRAVARTY_ET_AL_2015\n#' @templateVar CHAKRAVARTY_ET_AL_2015_P p. 118 f.\n#' @inheritParams CoopGameBaseParams\n#' @return The return value is a vector which contains the raw Banzhaf index for each player.\n#' @examples \n#' A<- cFuncApexVector(n = 4,apexPlayer=3)\n#' rawBanzhafIndex(A=A)\n#' #[1] 2 2 6 2\n#' \n#' #N=c(1,2,3), w=(50,49,1), q=51   \n#' A=cFuncQuotaVector(n=3, w=c(50,49,1),q=51)\n#' rawBanzhafIndex(A)\n#' #[1] 3 1 1\n#' \n#' A<-cFuncQuotaVector(n=3,w=c(50,30,20),q=c(67))\n#' rawBanzhafIndex(A)\n#' #[1] 3 1 1\n#' \nrawBanzhafIndex<-function(A){\n  if(!isSimpleGame(A)){\n    print(\"Game is not simple. Therefore no raw Banzhaf Index can be retrieved\")\n    return(NULL)\n  }\n  else\n  {\n    bi=BanzhafConcept(A)\n    n = getNumberOfPlayers(A)\n    return(calculatePowerIndex(bi))\n  }\n}\n\n\n\nlogicRawBanzhafValue=function(A){\n\n  retVal=NULL\n  bI=c()\n  \n  numberOfPlayers=getNumberOfPlayers(A)\n  bm=createBitMatrix(n=numberOfPlayers,A)\n  \n  for(i in 1:numberOfPlayers){\n    #Get all coalitions K where player i takes part\n    K=bm[bm[,i]==1,]\n    \n    #Get all coalitions K \\ {i}\n    KwithoutI=K\n    KwithoutI[,i]=0\n    #set v({})=0\n    KwithoutI[1,\"cVal\"]=0\n    \n    \n    for(k in 2:nrow(K)){\n      ix=indexCoalition(n=numberOfPlayers, S=getPlayersFromBMRow(KwithoutI[k,]))\n      KwithoutI[k, \"cVal\"]=bm[ix,\"cVal\"]\n    }\n    sumMarginalContributions=sum(K[,\"cVal\"]-KwithoutI[,\"cVal\"])\n    bI[i]=sumMarginalContributions#*banzhafFactor\n  }\n  \n  return (bI)\n}\n\n#' @title BanzhafConcept\n#' @noRd\n#' @include PointSolutionConcept.R\n#'# @exportClass BanzhafConcept\n\nsetClass(\n  \"BanzhafConcept\",\n  contains = \"PointSolutionConcept\"\n)\n\n#' @title Constructor for BanzhafConcept\n#' @noRd\n#' @template author/JA\n#' @name BanzhafConcept\n#' #@export\nBanzhafConcept<-function(A){\n  retBanzhafConcept=methods::new(\"BanzhafConcept\",A)\n  return(retBanzhafConcept)\n}\n\n#' @rdname calculatePowerIndex-methods\n#' @aliases calculatePowerIndex,BanzhafConcept-method\nsetMethod(\n  \"calculatePowerIndex\",\n  signature=\"BanzhafConcept\",\n  definition=function(.Object){\n    A<-.Object@A\n    result=logicRawBanzhafValue(A)\n    return(result)\n  }\n)\n\n#' @name drawNormalizedBanzhafIndex\n#' @title draw normalized Banzhaf Index for 3 or 4 players\n#' @description drawNormalizedBanzhafIndex draws the Banzhaf Value for 3 or 4 players. \\cr\n#'              Drawing any kind of Banzhaf values only makes sense from our point of view \\cr\n#'              for the normalized Banzhaf index for simple games, because \\cr\n#'              only in this case will the Banzhaf index be efficient.\n#' @aliases drawNormalizedBanzhafIndex\n#' @export drawNormalizedBanzhafIndex\n#' @template author/JA\n#' @template author/JS\n#' @template cites/PETERS_2015\n#' @templateVar PETERS_2015_P p. 367 ff.\n#' @template cites/CHAKRAVARTY_ET_AL_2015\n#' @templateVar CHAKRAVARTY_ET_AL_2015_P p. 118 f.\n#' @inheritParams CoopGameBaseParams\n#' @inheritParams visualize\n#' @examples\n#' A<-cFuncQuotaVector(n=3,w=c(50,30,20),q=c(67))\n#' drawNormalizedBanzhafIndex(A)\n#' \ndrawNormalizedBanzhafIndex<-function(A,holdOn=FALSE, colour = NA , label=TRUE, name = \"Normalized Banzhaf index\"){\n  A=GameVector(A)\n  bv=normalizedBanzhafIndex(A);\n  visualize(A, pointsToDraw=bv, holdOn=holdOn, colour = colour , label=label, name = name)\n}\n\n##normalized Banzhaf Index\n#' @name normalizedBanzhafIndex\n#' @title normalizedBanzhafIndex\n#' @description Normalized Banzhaf Index for a specified simple game \n#' @aliases normalizedBanzhafIndex\n#' @export normalizedBanzhafIndex\n#' @template author/JA\n#' @template author/JS\n#' @template cites/PETERS_2015\n#' @templateVar PETERS_2015_P p. 367 ff.\n#' @template cites/CHAKRAVARTY_ET_AL_2015\n#' @templateVar CHAKRAVARTY_ET_AL_2015_P p. 118 f.\n#' @inheritParams CoopGameBaseParams\n#' @return The return value is a vector which contains the normalized Banzhaf index for each player.\n#' @examples \n#' A<-cFuncQuotaVector(n=4,w=c(8,6,4,2),q=c(12))\n#' normalizedBanzhafIndex(A)\n#' #[1] 0.41666667 0.25000000 0.25000000 0.08333333\n#' \n#' A<- cFuncApexVector(n = 4,apexPlayer=3)\n#' normalizedBanzhafIndex(A=A)\n#' #[1] 0.1666667 0.1666667 0.5000000 0.1666667\n#' \n#' #N=c(1,2,3), w=(50,49,1), q=51   \n#' A=cFuncQuotaVector(n=3, w=c(50,49,1),q=51)\n#' normalizedBanzhafIndex(A)\n#' #[1] 0.6 0.2 0.2\n#' \n#' A<-cFuncQuotaVector(n=3,w=c(50,30,20),q=c(67))\n#' normalizedBanzhafIndex(A)\n#' #[1] 0.6 0.2 0.2\n#' \nnormalizedBanzhafIndex<-function(A){\n  if(!isSimpleGame(A)){\n    print(\"Game is not simple. Therefore no Normalized Banzhaf Index can be retrieved\")\n    return(NULL)\n  }\n  else\n  {\n    bc=BanzhafConcept(A)\n    bidcs=calculatePowerIndex(bc)\n    bidcs=bidcs/sum(bidcs)\n    return(bidcs)\n  }\n}\n\n## non-normalized Banzhaf Index\n#' @name nonNormalizedBanzhafIndex\n#' @title nonNormalizedBanzhafIndex\n#' @description non-normalized Banzhaf Index for a specified simple game\n#' @aliases nonNormalizedBanzhafIndex\n#' @export nonNormalizedBanzhafIndex\n#' @template author/JA\n#' @template author/JS\n#' @template cites/PETERS_2015\n#' @templateVar PETERS_2015_P p. 367 ff.\n#' @template cites/CHAKRAVARTY_ET_AL_2015\n#' @templateVar CHAKRAVARTY_ET_AL_2015_P p. 118 f.\n#' @inheritParams CoopGameBaseParams\n#' @return The return value is a vector which contains the nonnormalized Banzhaf index for each player.\n#' @examples \n#' A<-cFuncQuotaVector(n=4,w=c(8,6,4,2),q=c(12))\n#' nonNormalizedBanzhafIndex(A)\n#' #[1] 0.625 0.375 0.375 0.125\n#' \n#' A<- cFuncApexVector(n = 4,apexPlayer=3)\n#' nonNormalizedBanzhafIndex(A=A)\n#' #[1] 0.25 0.25 0.75 0.25\n#' \n#' #N=c(1,2,3), w=(50,49,1), q=51   \n#' A=cFuncQuotaVector(n=3, w=c(50,49,1),q=51)\n#' nonNormalizedBanzhafIndex(A)\n#' #[1] 0.75 0.25 0.25\n#' \n#' A<-cFuncQuotaVector(n=3,w=c(50,30,20),q=c(67))\n#' nonNormalizedBanzhafIndex(A)\n#' #[1] 0.75 0.25 0.25\n#' \nnonNormalizedBanzhafIndex<-function(A){\n  if(!isSimpleGame(A)){\n    print(\"Game is not simple. Therefore no Non-normalized Banzhaf Index can be retrieved\")\n    return(NULL)\n  }\n  else\n  {\n    bc=BanzhafConcept(A)\n    facBv=2^(getNumberOfPlayers(A)-1)\n    bidcs=calculatePowerIndex(bc)\n    bidcs=bidcs/facBv\n    return(bidcs)\n  }\n}\n",
    "created" : 1534234038183.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1100527976",
    "id" : "4DDCABDE",
    "lastKnownWriteTime" : 1536091312,
    "last_content_update" : 1536091312,
    "path" : "C:/Users/Johannes/Dropbox/UNIVERSITAET/Master_Inf/MASTER_ARBEIT/SVN_REPO/CoopGame/R/BanzhafConcept.R",
    "project_path" : "R/BanzhafConcept.R",
    "properties" : {
    },
    "relative_order" : 31,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}