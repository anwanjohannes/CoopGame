{
    "collab_server" : "",
    "contents" : "#' @name johnstonIndex\n#' @title johnstonIndex\n#' @description johnstonIndex calculates the Johnston index.\n#' @aliases johnstonIndex\n#' @export johnstonIndex\n#' @template author/JA\n#' @template author/MM\n#' @template author/JS\n#' @template cites/JOHNSTON_1977\n#' @templateVar JOHNSTON_1977_P pp. 1055 -- 1066\n#' @template cites/CHAKRAVARTY_ET_AL_2015\n#' @templateVar CHAKRAVARTY_ET_AL_2015_P p. 124\n#' @inheritParams CoopGameBaseParams\n#' @return Johnston Index for a specified simple game\n#' @examples\n#' #player 1 has 3 votes\n#' #player 2 has 2 votes\n#' #player 3 has 1 vote\n#' #majority for the decision is 4 (quota)\n#'\n#' #function call with game vector:\n#' A <- generateGameVector(cFuncQuota, n = 3, w = c(3,2,1), q = 4)\n#' #OR\n#' #A <- c(0,0,0,1,1,0,1)\n#'\n#' johnstonIndex(A)\n#' #[1] 0.6666667 0.1666667 0.1666667\n#' \njohnstonIndex<-function(A){\n  ji=JohnstonConcept(A)\n  return(calculatePowerIndex(ji))\n}\n\nlogicJohnstonIndex <- function(A) {\n  retVal = NULL\n  if(!isSimpleGame(A)){\n    print(\"Game is not simple. Therefore no Johnston Index can be retrieved\")\n  }\n  else \n  {\n    n <- getNumberOfPlayers(A)\n    bm <- createBitMatrix(n, A)\n    johnstonIndexVal <- rep.int(0, n)\n    \n    # gets the winning coalitions\n    winningCoalitions=bm[bm[,\"cVal\"]>0,,drop=FALSE]\n  \n    if (length(winningCoalitions)==0) {\n      print(\"There are no winning coalitions in this game\")\n    }\n    else\n    {\n  \n      mxRecVals <- matrix(ncol = n, nrow = nrow(winningCoalitions))\n    \n      # winning coalitions\n      # [1] 1 1 0\n      # [2] 1 0 1\n      # [3] 1 1 1\n    \n      for (r in 1:nrow(winningCoalitions)) {\n        tmpRow <- winningCoalitions[r, ]\n    \n        cntSwing <- 0\n        vecSwingPlayers <- c()\n    \n        for (i in 1:n) {\n          tmptmpRow <- tmpRow[1:n]\n          # set player i to zero - 1 1 0 -> 0 1 0\n          tmptmpRow[i] <- 0\n          # compare bit pattern with entry in bitmatrix and get corresponding coalition value\n          # null coalition generates no value\n          if (sum(tmptmpRow != 0)) {\n            ix <- indexCoalitionByBitVector(n, tmptmpRow)\n            cVal <- bm[ix, 'cVal']\n          } else {\n            cVal <- -1\n          }\n    \n          # check for each player in vulnerable coalition if player is critical (so called swing)\n          # count number of players being in swing position\n          if (cVal == 0) {\n            cntSwing <- cntSwing + 1\n            vecSwingPlayers <- c(vecSwingPlayers, 1)\n          } else {\n            vecSwingPlayers <- c(vecSwingPlayers, 0)\n          }\n        }\n        if (cntSwing == 0) {\n          recVal <- 0\n        } else{\n          # get reciprocal of number of swing players in coalition\n          recVal <- 1 / cntSwing\n        }\n        # multiply vector containing swing players with reciprocal of number of swing players\n        mxRecVals[r, ] <- vecSwingPlayers * recVal\n      }\n    \n      # sum up the reciprocal for each player\n      total <- colSums(mxRecVals)\n    \n      mxRecVals <- rbind(mxRecVals, total)\n    \n      totalNumberOfReciprocals <- sum(total)\n    \n      # The Johnston power of player i is the sum of the reciprocal of number of swings in\n      # vulnerable  coalition c in  which i is  critical, divided by the total number of reciprocal of\n      # number of swings in vulnerable coalition c of all players\n      if (totalNumberOfReciprocals != 0) {\n        johnstonIndexVal <- total / totalNumberOfReciprocals\n      }\n      retVal = johnstonIndexVal\n      }\n  }\n  return(retVal)\n}\n\n\n# a winning coalition is vulnerable if, among its members, there is at least\n# one  in  swing  position,  whose  swing  would  cause  the  coalition  to  lose.  Such  a  member  is\n# called  critical.  If  only  one  player  is  critical,  then  this  player  is  uniquely  powerful  in  the\n# coalition.\n# getWinningCoalitions <- function(bm) {\n#   winningCoalitions <- matrix()\n#   winningCoalitions <- bm[bm[ ,'cVal'] != 0, , drop = FALSE]\n# \n#   return(winningCoalitions)\n# }\n\n# isEmpty <- function(x){\n#   return(length(x) == 0)\n# }\n\n\n\n\n\n\n\n\n\n#' @title JohnstonConcept - S4 class for Johnston Concept\n#' @noRd\n#' @include PointSolutionConcept.R\n#' @slot A TODO\n#' #@exportClass JohnstonConcept\n\nsetClass(\n  \"JohnstonConcept\",\n  contains = \"PointSolutionConcept\"\n)\n\n#' @title Constructor for JohnstonConcept\n#' @noRd\n#' @template author/JA\n#' @name JohnstonConcept\n#' #@export\nJohnstonConcept<-function(A){\n  retJohnstonConcept=methods::new(\"JohnstonConcept\",A)\n  return(retJohnstonConcept)\n}\n\n#' @rdname calculatePowerIndex-methods\n#' @aliases calculatePowerIndex,JohnstonConcept-method\nsetMethod(\n  \"calculatePowerIndex\",\n  signature=\"JohnstonConcept\",\n  definition=function(.Object){\n    A<-.Object@A\n    return(logicJohnstonIndex(A))\n  }\n)\n#' @name drawJohnstonIndex\n#' @title drawJohnstonIndex for 3 or 4 players\n#' @description drawJohnstonIndex draws the Johnston Value for 3 or 4 players.\n#' @aliases drawJohnstonIndex\n#' @export drawJohnstonIndex\n#' @template cites/JOHNSTON_1977\n#' @templateVar JOHNSTON_1977_P pp. 1055 -- 1066\n#' @inheritParams CoopGameBaseParams\n#' @inheritParams visualize\n#' @examples\n#' A <- c(0,0,0,1,1,0,1)\n#' drawJohnstonIndex(A)\ndrawJohnstonIndex<-function(A,holdOn=FALSE, colour = NA , label=TRUE, name = \"Johnston value\"){\n  A=GameVector(A)\n  lgv=johnstonIndex(A);\n  visualize(A, pointsToDraw=lgv, holdOn=holdOn, colour = colour , label=label, name = name)\n}",
    "created" : 1525208698806.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "235884385",
    "id" : "5EB57A7C",
    "lastKnownWriteTime" : 1536091312,
    "last_content_update" : 1536091312,
    "path" : "C:/Users/Johannes/Dropbox/UNIVERSITAET/Master_Inf/MASTER_ARBEIT/SVN_REPO/CoopGame/R/JohnstonConcept.R",
    "project_path" : "R/JohnstonConcept.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}