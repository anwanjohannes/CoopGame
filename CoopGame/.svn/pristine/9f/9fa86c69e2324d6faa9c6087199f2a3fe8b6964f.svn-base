---
title: "The Abstract Calculation Algorithm of Nucleolus Derivates"
author: "Johannes Anwander"
date: "28 Januar 2018"
output: pdf_document
---

#### The Abstract Calculation Algorithm of Nucleolus Derivates

The general solution procedure can be described as follows:

**1st step: initial initialization of the linear program**

In the first step, the initialization of the linear program is performed in the `initialize` method in the object creation of a child object of nucleolus base.
In addition to the assignment of the game vector to the corresponding slot and the creation of an object of the type `LPCoopGameUtils`, both the coefficient matrix  and the border types and border values of the individual restrictions and the decision variables are included initialized to the corresponding vector for the target function coefficients.
A final call to the `updateLPCoopGameUtils` ensures that the previous GLPK LP solver is initialized according to the data specified in the `LPCoopGameUtils` class.
For the developer, there is given the possibility  for necessary adjustments with respect to the complete coefficient matrix to override the method `initLPMatrix`. If the derivative to be implemented only differs in the initial allocation of the structure variable to be minimized, it is sufficient to reimplement the `determineExcessCoefficients`.
For deviating initial assignments of the border types and limit values of the individual restrictions as well as the decision variables and destination function coefficients, it is necessary to redefine the methods `initLPRows` or `initLPBndsObjCoefs`.

**2nd step: Sequence of linear programs to determine the unique solution**

The determination of the unambiguous solution is made after the establishment of the initial linear program in a series of linear programs, controlled by the method `calculateNucleolus`.
Initially, the `checkGamePreconditions` method checks whether the defined game satisfies the essential property requirement for a clear solution.
In this case, in a loop with at most N iterations (in this case the number of restrictions, corresponds to the number of game vector entries in the case of the nucleolus), the following sub-steps are repeatedly run through.

**Partial steps:**

a) Solving the current linear program

b) Check for premature abort

c) Updating the Linear Program

d) checking for regular abort,
has the respective optimum been found for all restrictions?
* If YES: Cancel
* If NO: go back to substep a)

While stepping through substeps a to d, either the `checkAbort` method  caused a premature abort, where the method stops with an error message, or the specific point-valued solution is returned afterwards.
For the developer, there is also the possibility to intervene in step 2 and to consider specialities of the respective derivative.
On the one hand, the developer can define different termination criteria by overriding `checkAbort`, on the other hand, he can also influence the update of the linear program by the method `updateNucleolusBase`.
The `updateNucleolusBase` method, in turn, includes calls to methods such as `updateLPMatrix`, `updateLPRows`, and `updateLPBndsObjCoefs`, which can be overwitten as needed. For `updateLPMatrix` there is hardly any need to overwrite it. By default, it only sets the entries of the last column for the structure variable to be minimized from the objective function in the coefficient matrix to 0. This behavior was the same as in all previous implementations.
On the other hand, differences in the derivatives are clearly evident with respect to the updating of the border types as well as the limits of the individual restrictions. This was taken into account by reimplementing the `updateLPRows` for large and small deviations of the `getLPRowsBoundsFunc` method.
The `getLPRowsBoundsFunc` method is called to determine the respective threshold value - for the restriction where the optimal value was found.
For the sake of completeness as well as better separation and to be prepared for any differences, the `updateLPBndsObjCoefs` method is also listed. Although this method bears no logic, it should provide the possibility for adjustment if the barrier values and types as well as the coefficients for the objective function are updated.
The following section deals with the respective implementations.