#' @title GameVector -  class for game vector
#' @description class for game vector
#' @exportClass GameVector

setClass(
  "GameVector",
  contains = "numeric",
  validity = function(object){
     paramCheckResult=getEmptyParamCheckResult()
     stopOnInvalidGameVectorA(paramCheckResult,A=(object))
  }
)

setMethod(
  f="initialize",
  signature = "GameVector",
  definition =  function(.Object, A) {
    paramCheckResult=getEmptyParamCheckResult()
    if(!is.null(A)){
      stopOnInvalidGameVectorA(paramCheckResult,A=A)
      .Object@.Data=A
    }
    methods::validObject(.Object)
    return(.Object)
  }
)

#' @title Constructor for AllocationPropertyGameVector
#' @template author/JA
#' @name GameVector
#' @export GameVector
GameVector<-function(A){
  retAP=methods::new("GameVector",A)
  return(retAP)
}


#' @title Method getDualGame
#' @description This method retrieves the dual game.
#' @rdname getDualGame-methods
#' @name getDualGame
#' @docType methods
#' @template author/JA
#' @template param/Object
#' @exportMethod getDualGame
setGeneric("getDualGame",function(.Object){standardGeneric("getDualGame")})

#' @rdname getDualGame-methods
#' @aliases getDualGame,GameVector-method
setMethod(
  "getDualGame",
  signature = "GameVector",
  definition = function(.Object){
    A<-.Object@.Data
    N=length(A)
    return(c(A[N]-rev(A[-N]),A[N]))
  }
)

#' @name getDualGameVector
#' @title getDualGameVector for n-player TU Games
#' @description Computes the dual game for a given game specified by a game vector A.
#' @aliases getDualGameVector
#' @export getDualGameVector
#' @template author/JA
#' @template cites/PELEG_ET_SUDHOELTER_2007
#' @templateVar PELEG_ET_SUDHOELTER_2007_P p. 125
#' @inheritParams CoopGameBaseParams
#' @return Numeric vector of length (2^n)-1 representing the dual game.
#' @examples
#' A<-cFuncUnanimityVector(4,c(1,2))
#' #[1] 0 0 0 0 1 0 0 0 0 0 1 1 0 0 1
#' getDualGameVector(A)
#' #[1] 1 1 0 0 1 1 1 1 1 0 1 1 1 1 1
getDualGameVector<-function(A){
  gv<-GameVector(A);
  dualGame<-getDualGame(gv)
  return(dualGame)
}



#' @name generateGameVector
#' @title generating game vector
#' @description Generates game vector for given number of players and function
#' @aliases generateGameVector
#' @include bitMatrix.R
#' @export generateGameVector
#' @template author/AT
#' @param func function for the game, which can return a payoff for given coalition of players,
#'        func has to have a parameter called 'S' for the current coalition
#' @param n is the number of players in the cooperate game
#' @param ... for any further parameter (parameters for func)
#' @return generated numeric game vector with 2^n-1 elements (n=number of players)
#' @examples
#' #unanimity game
#' cFuncUnanimity=function(S,T){
#'  retVal=0
#'  playersInS = (T %in% S)
#'  boolTinS=length(playersInS)==length(playersInS[playersInS==TRUE])
#'  if (boolTinS) {
#'    retVal=1
#'  }else{
#'    retVal=0
#'  }
#'  return (retVal)
#'  }
#'  generateGameVector(func = cFuncUnanimity, n = 3, T=c(1,2))
generateGameVector<-function(v,n,...){
  paramCheckResult=getEmptyParamCheckResult()
  stopOnInvalidCoalitionFunctionV(paramCheckResult,v)
  stopOnInvalidNumberOfPlayers(paramCheckResult,n)
  #stop on v no function
  cFunc=v(n=n,...)
  #stop oncFunc no Coalition class
  gameVector=cFunc@A
  return(gameVector)
}

#' @name getNumberOfPlayers
#' @title getNumberOfPlayers
#' @description Gets the number of players from a game vector A
#' @aliases getNumberOfPlayers
#' @export getNumberOfPlayers
#' @template author/MM
#' @param A  is a numeric vector of dimension 1x((2^n) - 1)
#' @return number of players
#' @examples
#' A=c(0,0,0,60,60,60,72)
#' getNumberOfPlayers(A)
#' #[1] 3

getNumberOfPlayers <- function(A) {
  A<-GameVector(A)
  n <- log2(length(A) + 1)
  numberOfPlayers<-NumberOfPlayers(n)
  return(numberOfPlayers)
}
