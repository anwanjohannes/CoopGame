boolSkip=F


balancedgame3 <- function(A){
  v1=A[1]
  v2=A[2]
  v3=A[3]
  v12=A[4]
  v13=A[5]
  v23=A[6]
  v123=A[7]
  
  #Code orientiert sich anTugLab. Dateiname: balancedgame
  #Funktion: balancedgame3 Zeile: 106
  B=! (v123<(v1+v2+v3) | v123<(v1+v23) | v123<(v2+v13) | v123<(v3+v12) | v123<1/2*(v12+v13+v23));
  
  if(B == TRUE){
    return(1)
  }
  else{
    return(0)
  }
}

balancedgame4 <- function(A){
  v1=A[1]
  v2=A[2]
  v3=A[3]
  v4=A[4]
  v12=A[5]
  v13=A[6]
  v14=A[7]
  v23=A[8]  
  v24=A[9]
  v34=A[10]
  v123=A[11]
  v124=A[12]
  v134=A[13]
  v234=A[14]
  v1234=A[15]
  
  #Code orientiert sich an TugLab. Dateiname: balancedgame 
  #Funktion: balancedgame4 Zeile: 129 - 135
  B= !(v1234<(v1+v2+v3+v4) |
         v1234<(v1+v234) | v1234<(v2+v134) | v1234<(v3+v124) | v1234<(v4+v123) |
         v1234<(v1+v2+v34) | v1234<(v1+v3+v24) | v1234<(v1+v4+v23) | v1234<(v2+v3+v14) | v1234<(v2+v4+v13) | v1234<(v3+v4+v12) | 
         v1234<1/3*(v123+v124+v134+v234) | 
         v1234<(1/3*(v12+v13+v14)+2/3*(v234)) | v1234<(1/3*(v12+v23+v24)+2/3*(v134)) | v1234<(1/3*(v23+v13+v34)+2/3*(v124)) | v1234<(1/3*(v24+v34+v14)+2/3*(v123)) |
         v1234<1/2*(v12+v134+v234) | v1234<1/2*(v13+v124+v234) | v1234<1/2*(v14+v123+v234) | v1234<1/2*(v23+v134+v124) | 
         v1234<1/2*(v24+v134+v123) | v1234<1/2*(v34+v123+v124));
  
  if(B == TRUE){
    return(1)
  }
  else{
    return(0)
  }
  
}


corevertices4 <- function(A){
  
  #Code orientiert sich an TugLab. Dateiname: corevertices 
  #Funktion: corevertices4 Zeile: 161-243
  
  v1=A[1]
  v2=A[2]
  v3=A[3]
  v4=A[4]
  v12=A[5]
  v13=A[6]
  v14=A[7]
  v23=A[8]  
  v24=A[9]
  v34=A[10]
  v123=A[11]
  v124=A[12]
  v134=A[13]
  v234=A[14]
  v1234=A[15]
  
  balanced=balancedgame4(A)
  if(balanced==0) { # nicht balanced -> Kern ist leer
    corepoints=0
  } else { # balanced -> Kern existiert
    # convex=convexgame4(A) # changed due to ticket #1803
    if(isConvexGame(A)$isConvexGame) { # convex -> Kern != Webermenge
      corepoints=webervertices4(A)
    } else { # nicht convex -> Kern berechnen
      
      n1 =c(1,   0,  0)
      n2 =c(-1,  0,  0)
      n3 =c(0,   1,  0)
      n4 =c(0,  -1,  0)
      n5 =c(0,   0,  1)
      n6 =c(0,   0, -1)
      n7 =c(1,   1,  1)
      n8 =c(-1, -1, -1)
      n9 =c(1,   1,  0)
      n10=c(-1, -1,  0)
      n11=c(1,   0,  1)
      n12=c(-1,  0, -1)
      n13=c(0,   1,  1)
      n14=c(0,  -1, -1)
      nucleo = rbind(n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11,n12,n13,n14)
      
      b=matrix(c(v1,
                 -v1234+v234,
                 v2,
                 -v1234+v134,
                 v3,
                 -v1234+v124,
                 v123,
                 -v1234+v4,
                 v12,
                 -v1234+v34,
                 v13,
                 -v1234+v24,
                 v23,
                 -v1234+v14
      ), ncol=1)
      
      # Z.209-224
      # Schnittpunkte holen
      intersecciones=schnittpunkte()
      #load(file="KoopGame/data/intersecciones.RData")
      C=matrix(ncol=3)
      first=1 # Hilfsvariable
      for(II in 1:nrow(intersecciones)) {
        ii=intersecciones[II,1]
        jj=intersecciones[II,2]
        kk=intersecciones[II,3]
        AA=rbind(nucleo[ii,],nucleo[jj,],nucleo[kk,])
        BB=c(b[ii],b[jj],b[kk])
        
        ab1=c(nucleo[ii,],b[ii])
        ab2=c(nucleo[jj,],b[jj])
        ab3=c(nucleo[kk,],b[kk])
        AABB = rbind(ab1,ab2,ab3)
        
        if(qr(AA)$rank==3) {
          hh=solve(AA) %*% BB
          C=rbind(C,t(hh))
        }
        else {
          C=C
        }
        if(nrow(C)==2 && first==1) { # 1. Zeile löschen
          C=C[2,]
          first=0
        }
      }
      C=unique(C)
      
      ## ----------------------------------------
      # Weberpunkte, die zum Kern gehoeren, berechnen
      Wpoints=webervertices4(A)
      # ----------------------------------------
      # Ist nicht notwendig, da webervertices4 bereits die
      # doppelten Punkte entfernt. Steht zur Sicherheit drin,
      # falls unique mal aus webervertices4 entfernt werden
      # sollte.
      Wpoints=unique(Wpoints)
      # ----------------------------------------
      # Fuer jede Zeile in Wpoints wird geprueft, ob der Punkt
      # im Kern liegt. Wenn der Punkt im Kern liegt, wird er
      # zur Matrix CW hinzugefuegt.
      first=1 # Es ist der erste Punkt im Kern
      for(i in 1:nrow(Wpoints)) {
        # Wpoints[c(i),c(1,2,3)] -> Es werden nur die ersten
        # drei Spalten der Zeile i mitgegeben
        if(1==belongtocore4(A,Wpoints[c(i),c(1,2,3)])) { # Punkt im Kern
          if(first==1) { # Erster Punkt im Kern
            CW=matrix(Wpoints[i,],ncol=4)
            first=0 # Erster Punkt hinzugefuegt
          }
          else { # Weiterer Punkt im Kern
            CW=rbind(CW,Wpoints[i,])
          }
        }
      }
      if(first==1) {
        CW=0
      }
      ## ----------------------------------------
      
      # Punkte, die zum Kern gehoeren, berechnen
      first=1 # Es ist der erste Punkt im Kern
      for(i in 2:nrow(C)) {
        #         print("Zeile in C: ")
        #         print(i)
        #         print("belongtocore4")
        #         print(belongtocore4(A,C[c(i),c(1,2,3)]))
        if(1==belongtocore4(A,C[c(i),c(1,2,3)])) { # Punkt im Kern
          if(first==1) { # Erster Punkt im Kern
            CC=matrix(C[i,],ncol=3)
            first=0 # Erster Punkt hinzugefuegt
          }
          else { # Weiterer Punkt im Kern
            CC=rbind(CC,C[i,])
          }
        }
      }
      CC=efficiency(CC,v1234)
      
      if(CW==0){
        corepoints=CC
      }
      else {
        corepoints=rbind(CW,CC)
      }
      corepoints=unique(corepoints)
    }
  }
  return(corepoints)
}

convexhullextremes <- function(A, Wpoints) {
  
  #Code orientiert sich an TugLab. Dateiname: convexhullextremes
  #Funktion: convexhullextremes Zeile: 112-118
  
  #Bei Vektoren mit 3 Punkten oder weniger,kann nichts berechent werden
  if(length(A) < 4){
    extremes=Wpoints
    return(extremes)
  }
  
  #berechnet die Konvexe H?lle
  referencia = chull(t(Wpoints[,1]),t(Wpoints[,2]))
  
  #ordnet die Zeilen der Matrix nach referencia
  Wextremes=Wpoints[referencia,]
  
  return(Wextremes)
}

webervertices3 <- function(A) {
  
  v1=A[1]
  v2=A[2]
  v3=A[3]
  v12=A[4]
  v13=A[5]
  v23=A[6]
  v123=A[7]
  
  #Code orientiert sich an TugLab. Dateiname: webervertices
  #Funktion: webervertices3 Zeile: 78-84
  
  # Weberpunkte berechnen und in einer Matrix speichern
  m1 = matrix(c(v1,       v12-v1,   v123-v12), nrow=1, ncol=3)
  m2 = matrix(c(v1,       v123-v13, v13-v1),   nrow=1, ncol=3)
  m3 = matrix(c(v12-v2,   v2,       v123-v12), nrow=1, ncol=3)
  m4 = matrix(c(v123-v23, v2,       v23-v2),   nrow=1, ncol=3)
  m5 = matrix(c(v13-v3,   v123-v13, v3),       nrow=1, ncol=3)
  m6 = matrix(c(v123-v23, v23-v3,   v3),       nrow=1, ncol=3)
  WP = rbind(m1,m2,m3,m4,m5,m6)
  
  #l?scht die doppelten Zeilen in der Matrix
  WP=unique(WP)
  #Speichert die ersten zwei Spalten der Matrix WP in Wpoints
  Wpoints=WP[,1:2]
  
  #ruft die Funktion convexhullextremes auf mit dem ?bergabeparameter Wpoints
  #CHANGE: Johannes Anwander (on 20151228) added A as parameter
  Wextremes=convexhullextremes(A, Wpoints)
  
  Webervertices=efficiency(Wextremes,v123)
  return(Webervertices)
}


#  Version 1.1
#  Datum: 10.05.2015
# title efficiency for 3 Player or 4 Player
# description Adds the last component of a vector to be an efficient allocation.
# aliases efficiency
# author Kuebra Tokay, Fatma Tokay
# param b should be a nx2 or nx3 matrix and vn a scalar.
# return v is a matrix obtained by adding to matrix b one column, 
#         such that the row vectors of v are efficient allocations.
# examples
# A=c(0,0,0,40,50,20,100) 
# A=c(0,0,0,6,5,5,10) 
# A=c(0,0,0,0,7,7,7,7,7,7,12,12,12,12,22) 
# 
# efficiency(A)

efficiency <- function(b,vn){
  
  #Formel von TugLab. Dateiname: efficiency Funktion: efficiency Zeile: 50-56
  
  #ermittelt die Spaltenlaenge
  rowlength= dim(b)[2];
  if (rowlength==2) {
    #berechnet die letzte Spalte 
    lastcol = vn-b[,1]-b[,2]
    #verbindet die Matrix b mit der letzten Spalte
    mat = cbind(b,lastcol);
    
  }
  else if (rowlength==3){
    
    lastcol = vn-b[,1]-b[,2]-b[,3]
    
    mat = cbind(b,lastcol);
  }
  else {
    print("Vector b exceeds the dimensions");
  }
}


corevertices3 <- function(A) {
  
  
  #Code orientiert sich an TugLab. Dateiname: corevertices 
  #Funktion: corevertices3 Zeile: 111-158
  
  v1=A[1]
  v2=A[2]
  v3=A[3]
  v12=A[4]
  v13=A[5]
  v23=A[6]
  v123=A[7]
  
  # Pruefen, ob das Spiel ausgeglichen ist.
  B=balancedgame3(A)
  
  # Das Spiel ist nicht balanced. Es existiert kein Kern.
  if(B==0) { 
    corepoints=0
  }
  # Das Spiel ist balanced. Es existiert ein Kern.
  else { 
    # Pruefen, ob der Kern gleich den Weberpunkten ist
    if(isConvexGame(A)$isConvexGame) { #changed according to ticket #1803
      # Der Kern entspricht den Weberpunkten
      corepoints=webervertices3(A)
    } else { 
      # Der Kern entspricht nicht den Weberpunkten
      # Z.122-129 weggelassen
      
      # Z.131-132 Weberpunkte berechnen
      W=webervertices3(A)
      # Z.133 Weberpunkte auf zwei Spalten reduzieren
      Wpoints=W[,c(1,2)]
      # Z.134 Doppelte Weberpunkte entfernen
      Wpoints = unique(Wpoints)
      
      # Z.136 Stellt den Kern zusammen
      c1 = matrix(c(v123-v23,       v12+v23-v123), nrow=1, ncol=2)
      c2 = matrix(c(v123-v23,       v123-v13), nrow=1, ncol=2)
      c3 = matrix(c(v12+v13-v123,   v123-v13), nrow=1, ncol=2)
      c4 = matrix(c(v1,                   v2), nrow=1, ncol=2)
      c5 = matrix(c(v123-v3-v2,           v2), nrow=1, ncol=2)
      c6 = matrix(c(v1,           v123-v1-v3), nrow=1, ncol=2)
      C  = rbind(c1,c2,c3,c4,c5,c6)
      
      # Z.137 Doppelte Zeilen loeschen
      C = unique(C)
      
      # Z.139-142
      checkcore = matrix(NA,1,nrow(Wpoints))
      for(i in 1:nrow(Wpoints)) {
        checkcore[i]=belongtocore3(A,Wpoints[i,])
      }
      # Z:143-144
      first=1
      for(i in 1:ncol(checkcore)) {
        if(checkcore[i]==1) {
          if(first==1) {
            CW=matrix(Wpoints[i,],ncol=2)
            first=0
          } else {
            CW = rbind(CW,Wpoints[i,])
          }
        }
      }
      
      # Z.146-150
      checkcore = matrix(NA,1,nrow(C))
      for(i in 1:nrow(C)) {
        checkcore[i]=belongtocore3(A,C[i,])
      }
      # Z.151-152
      for(i in 1:ncol(checkcore)) {
        if(checkcore[i]==1) {
          CW = rbind(CW,C[i,])
        }
      }
      corepoints=efficiency(CW,v123)
      corepoints=unique(corepoints)
    }
    return(corepoints)
  }
}





corevertices4 <- function(A){
  
  #Code orientiert sich an TugLab. Dateiname: corevertices 
  #Funktion: corevertices4 Zeile: 161-243
  
  v1=A[1]
  v2=A[2]
  v3=A[3]
  v4=A[4]
  v12=A[5]
  v13=A[6]
  v14=A[7]
  v23=A[8]  
  v24=A[9]
  v34=A[10]
  v123=A[11]
  v124=A[12]
  v134=A[13]
  v234=A[14]
  v1234=A[15]
  
  balanced=balancedgame4(A)
  if(balanced==0) { # nicht balanced -> Kern ist leer
    corepoints=0
  } else { # balanced -> Kern existiert
    # convex=convexgame4(A) # changed due to ticket #1803
    if(isConvexGame(A)$isConvexGame) { # convex -> Kern != Webermenge
      corepoints=webervertices4(A)
    } else { # nicht convex -> Kern berechnen
      
      n1 =c(1,   0,  0)
      n2 =c(-1,  0,  0)
      n3 =c(0,   1,  0)
      n4 =c(0,  -1,  0)
      n5 =c(0,   0,  1)
      n6 =c(0,   0, -1)
      n7 =c(1,   1,  1)
      n8 =c(-1, -1, -1)
      n9 =c(1,   1,  0)
      n10=c(-1, -1,  0)
      n11=c(1,   0,  1)
      n12=c(-1,  0, -1)
      n13=c(0,   1,  1)
      n14=c(0,  -1, -1)
      nucleo = rbind(n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11,n12,n13,n14)
      
      b=matrix(c(v1,
                 -v1234+v234,
                 v2,
                 -v1234+v134,
                 v3,
                 -v1234+v124,
                 v123,
                 -v1234+v4,
                 v12,
                 -v1234+v34,
                 v13,
                 -v1234+v24,
                 v23,
                 -v1234+v14
      ), ncol=1)
      
      # Z.209-224
      # Schnittpunkte holen
      intersecciones=schnittpunkte()
      #load(file="KoopGame/data/intersecciones.RData")
      C=matrix(ncol=3)
      first=1 # Hilfsvariable
      for(II in 1:nrow(intersecciones)) {
        ii=intersecciones[II,1]
        jj=intersecciones[II,2]
        kk=intersecciones[II,3]
        AA=rbind(nucleo[ii,],nucleo[jj,],nucleo[kk,])
        BB=c(b[ii],b[jj],b[kk])
        
        ab1=c(nucleo[ii,],b[ii])
        ab2=c(nucleo[jj,],b[jj])
        ab3=c(nucleo[kk,],b[kk])
        AABB = rbind(ab1,ab2,ab3)
        
        if(qr(AA)$rank==3) {
          hh=solve(AA) %*% BB
          C=rbind(C,t(hh))
        }
        else {
          C=C
        }
        if(nrow(C)==2 && first==1) { # 1. Zeile löschen
          C=C[2,]
          first=0
        }
      }
      C=unique(C)
      
      ## ----------------------------------------
      # Weberpunkte, die zum Kern gehoeren, berechnen
      Wpoints=webervertices4(A)
      # ----------------------------------------
      # Ist nicht notwendig, da webervertices4 bereits die
      # doppelten Punkte entfernt. Steht zur Sicherheit drin,
      # falls unique mal aus webervertices4 entfernt werden
      # sollte.
      Wpoints=unique(Wpoints)
      # ----------------------------------------
      # Fuer jede Zeile in Wpoints wird geprueft, ob der Punkt
      # im Kern liegt. Wenn der Punkt im Kern liegt, wird er
      # zur Matrix CW hinzugefuegt.
      first=1 # Es ist der erste Punkt im Kern
      for(i in 1:nrow(Wpoints)) {
        # Wpoints[c(i),c(1,2,3)] -> Es werden nur die ersten
        # drei Spalten der Zeile i mitgegeben
        if(1==belongtocore4(A,Wpoints[c(i),c(1,2,3)])) { # Punkt im Kern
          if(first==1) { # Erster Punkt im Kern
            CW=matrix(Wpoints[i,],ncol=4)
            first=0 # Erster Punkt hinzugefuegt
          }
          else { # Weiterer Punkt im Kern
            CW=rbind(CW,Wpoints[i,])
          }
        }
      }
      if(first==1) {
        CW=0
      }
      ## ----------------------------------------
      
      # Punkte, die zum Kern gehoeren, berechnen
      first=1 # Es ist der erste Punkt im Kern
      for(i in 2:nrow(C)) {
        #         print("Zeile in C: ")
        #         print(i)
        #         print("belongtocore4")
        #         print(belongtocore4(A,C[c(i),c(1,2,3)]))
        if(1==belongtocore4(A,C[c(i),c(1,2,3)])) { # Punkt im Kern
          if(first==1) { # Erster Punkt im Kern
            CC=matrix(C[i,],ncol=3)
            first=0 # Erster Punkt hinzugefuegt
          }
          else { # Weiterer Punkt im Kern
            CC=rbind(CC,C[i,])
          }
        }
      }
      CC=efficiency(CC,v1234)
      
      if(CW==0){
        corepoints=CC
      }
      else {
        corepoints=rbind(CW,CC)
      }
      corepoints=unique(corepoints)
    }
  }
  return(corepoints)
}

test_that("Check 59.1 - test corevertices against corevertices3" ,{
  if(boolSkip){
    skip("Test was skipped")
  }
  for(i in 1:1000){
    P=sample(1:20,7,replace = TRUE)
    result=corevertices(P)
    result2=corevertices3(P)
    
    if(is.character(result)){
      expect_equal(result2,0)
    }else if(nrow(result)==0){
      expect_equal(result2,0)
    }else{
      dimnames(result2)<-NULL
      dimnames(result)<-NULL
      result=result[do.call(order,as.data.frame(result)),]
      result2=result2[do.call(order,as.data.frame(result2)),]
      expect_equal(result, result2)
    }
    
  }
})


test_that("Check 59.2 - test corevertices against corevertices4" ,{
  if(boolSkip){
    skip("Test was skipped")
  }
  for(i in 1:1000){
    P=sample(1:20,15,replace = TRUE)
    result=corevertices(P)
    result2=corevertices4(P)
    
    if(is.character(result)){
      expect_equal(result2,0)
    }else if(nrow(result)==0){
      expect_equal(result2,0)
    }else{
      result=result[do.call(order,as.data.frame(result)),]
      result2=result2[do.call(order,as.data.frame(result2)),]
      expect_equal(result, result2)
    }
    
  }
})