#' @name nevisonIndex
#' @title nevisonIndex
#' @description Calculates the Nevison Index for a specified simple TU game.
#' @aliases nevisonIndex
#' @export nevisonIndex
#' @template author/JS
#' @template cites/NEVISON_1979
#' @templateVar NEVISON_1979_P pp. 39 -- 57
#' @inheritParams CoopGameBaseParams
#' @return Nevison Index for a specified simple game 
#' @examples 
#' A=c(0,0,0,1,1,0,1)
#' nevisonIndex(A) 
#' #result: [1] 0.75 0.50 0.50
#' # Note that in general the Nevison Index is not an efficient vector, 
#' # i.e. the sum of its entries is not always 1.
nevisonIndex<-function(A){
  nevison=nevisonConcept(A)
  return(calculatePointSolution(nevison))
}


#' @name nevisonValue
#' @title nevisonValue
#' @description nevisonValue is a solution concept based on the nevison Index
#' @aliases nevisonValue
#' @export nevisonValue
#' @template author/JS
#' @template cites/NEVISON_1979
#' @templateVar NEVISON_1979_P pp. 39 -- 57
#' @inheritParams CoopGameBaseParams
#' @return The return value is a vector which contains for each player the calculated Public Help value
#' @examples 
#' A=c(0,0,0,1,1,0,1)
#' nevisonValue(A)
#' #result: [1] 0.75 0.50 0.50
#' # Note that in general the Nevison value is not an efficient vector, 
#' # i.e. the sum of its entries is not always 1.
nevisonValue<-function(A){
  if(!isSimpleGame(A)){
    print("Game is not simple. Therefore no Nevison Value can be retrieved")
  }
  else
  {
    phv=nevisonConcept(A)
    return(calculatePointSolution(phv))
  }
}


logicNevisonIndex=function(A){
  if(!isSimpleGame(A)){
    print("Game is not simple. Therefore no Nevison Index can be retrieved")
  }
  else
  {
    n=getNumberOfPlayers(A)
    bm=createBitMatrix(n,A)
    #the winning coalitions
    wcs=bm[bm[,"cVal"]>0,,drop=FALSE]
    #the values of corresponding where 
    temp=sapply(c(1:n),function(i){sum(wcs[wcs[,i]==1,"cVal"])})
    nevison =sapply(c(1:n),function(i){temp[i]/2^(n-1)})
    return(nevison=nevison)
  }
}

#' @title nevisonConcept
#' @noRd
#' @description nevisonConcept
#' @include PointSolutionConcept.R
# @exportClass nevisonConcept

setClass(
  "nevisonConcept",
  contains = "PointSolutionConcept"
)

#' @rdname calculatePowerIndex-methods
#' @aliases calculatePowerIndex,nevisonConcept-method
setMethod(
  "calculatePointSolution",
  signature="nevisonConcept",
  definition=function(.Object){
    A<-.Object@A
    return(logicNevisonIndex(A))
  }
)

#' @title Constructor for nevisonConcept
#' @noRd
#' @template author/JS
#' @name nevisonConcept
#' #@export
nevisonConcept<-function(A){
  retnevisonIndex=methods::new("nevisonConcept",A)
  return(retnevisonIndex)
}



#' @name drawNevisonValue
#' @title drawNevisonValue for n players
#' @description drawNevisonValue draws the Nevison Value for n players.
#' @aliases drawNevisonValue
#' @export drawNevisonValue
#' @template author/JS
#' @template cites/NEVISON_1979
#' @templateVar NEVISON_1979_P pp. 39 -- 57
#' @inheritParams CoopGameBaseParams
#' @inheritParams visualize
#' @return Nevison Value for given game vector with n players
#' @examples
#' A=c(0,0,0,1,1,0,1)
#' drawNevisonValue(A) 
drawNevisonValue<-function(A,holdOn=FALSE, colour = NA , label=TRUE, name = "Nevison Value"){
  A=GameVector(A)
  sm=nevisonValue(A);
  visualize(A, pointsToDraw=sm, holdOn=holdOn, colour = colour , label=label, name = name)
}
